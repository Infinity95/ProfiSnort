\section{Packetbeschreibung}

\subsection{\textbf{\sppname}}

\subsection{\textbf{command}}

Die Kernfunktionalität innerhalb des Programms stellt das \textbf{command Paket}.
Darin befinden sich sowohl die Hierarchie, vorhandene Datenstruktur als auch jede
mögliche Command-Klasse und deren Interface. Vom Prinzip her vergleichbar mit
Runnables.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/commands.png}
  \caption{\textbf{command Paket}}
\end{figure}

Es gibt 2 Hauptarten von Commands, UserCommands für die Verwaltung der
Benutzeroberflächenbefehle, und TruffleCommands für die Methodenaufrufe im
Model-Graph, also die Hauptarbeit am Model. Die Commands machen außerdem den
Hauptteil der Log-Datein und damit der Video-Funktion aus. Mehr dazu im
service-Unterpackage datalogging.

\subsection*{\textbf{commanqueue}}
Die besagte Datenstruktur, welche beispielsweise der executor besitzt. Es
sind ggf. mehrere tatsächliche Queues vorhanden, was einen Manager verlangt
um nach dem Round-Robin-Prinzip faire Verteilung zu ermöglichen.


\subsection{\textbf{service}}


In unserem Entwurf haben wir uns außerdem dazu entschieden einzelne
durchlaufende Arbeitsschritte in das \textbf{service Paket} auszulagern.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/service.png}
  \caption{\textbf{service Paket}}
  \medskip
\end{figure}

    \subsection*{\textbf{truffleprocessor}}
    Der \textbf{truffleprocessor} ist die Empfangsstelle für die von uns in der
    \gls{ipc} benutzen Truffles. Außerdem erzeugt er die später verwendeten
    Commands und benachrichtigt als \gls{notifier}.

    \subsection*{\textbf{datalogging}}
    Das \textbf{datalogging} kümmert sich um die gesamte gewünschte
    Speicherung/Loggen und, falls implementiert, die Verfügbarkeit der
    Video-Daten. Es speichert sowohl regelmäßige Snapshots des gesamten
    Graphen, als auch einzelne Commands für eine Schrittweise Rückverfolgung
    des Ablaufes.

    \subsection*{\textbf{executor}}
    Der \textbf{executor} ist das Unterpackage, in welchem die Anwendung bzw.
    Ausführung der Commands stattfindet. Er ist ein \gls{listener} für Commands
    von sowohl dem view-Package als auch dem truffleprocessor.


\subsection{\textbf{presenter}}


Der \textbf{presenter} ist für den Aufbau von \gls{programname}, also das
Initialisieren, Instanziieren und Referenzieren aller Programmelemente zuständig.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/presenter.png}
  \caption{\textbf{presenter}}
\end{figure}

Er ist der erste Thread und erzeugt alle weiteren, zum Beispiel einen für jeden
Service. Außerdem liest er aus einer Settings-Datei und stellt das Programm ein.
Das heisst er initialisiert bestimmte Attribute entsprechend. Danach erschöpft
sich die Nützlichkeit des \textbf{presenter} bis zu einem neuen Programmstart.


\subsection{\textbf{util}}


Unsere Variante des \gls{observerpattern}s.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/util.png}
  \caption{\textbf{util Packet}}
\end{figure}

Da wir sowohl Interfaces als auch Klassen bzw. abstrakte Klassen als
\gls{notifier} haben, kommen wir nicht um eine Modifizierung des klassischen
\gls{observerpattern} herum. Nun haben wir die Möglichkeit sowohl ein
\gls{notifier}-Interface zu erweitern als auch eine abstrakte
\gls{notifier}-Klasse zu beerben. Der \gls{listener} funktioniert genau wie ein
Observer.


\subsection{\textbf{model}}


Die Hauptdatenstruktur von \gls{programname}: das \textbf{model Paket}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/model.png}
  \caption{\textbf{model Paket}}
\end{figure}

    \subsection*{\textbf{graph}}

    \subsection*{\textbf{filter}}

    \subsection*{\textbf{settingsdata}}

    \subsection*{\textbf{graphlog}}


\subsection{\textbf{view}}


\subsection{\textbf{interactors}}
