chapter{Aufbau \programname}

\section{Architekturbeschreibung}
Im Groben gehalten funktioniert der Daten- und Befehlsfluss im Trufflehog-Entwurf
wie im klassischen \gls{mvc}. Der Presenter aktiviert Services, welche das Model basierend
auf empfangenem Netzwerkverkehr verändert und das View aktualisiert sich am Model.
Da viele Threads im Programm parallel durchlaufen aber dennoch kommunizieren müssen,
verlassen wir uns an einigen Stellen auf das \gls{observerpattern} mit einer
Multi-Thread kompatiblen Datenstruktur.\newline
\newline

\section{Paketbeschreibung}

\subsection{command}
\label{subsec:command}
Das command-Package beinhaltet alle Commands, deren Struktur und die Datenstruktur
\textit{CommandQueue}. Ein Command ist ein Befehl, der auf
dem Model ausgeführt wird. Das heißt alle Objekte, die das Model irgendwie verändern,
werden als Command gekapselt, sodass die Veränderung auf dem Model
ausgeführt werden kann. Es werden alle empfangene Netzwerkpakete
und Benutzerbefehle als Command gekapselt, da diese direkt das Model beeinflussen
indem sie beim Executor ausgeführt werden.
\newline
\newline
Dieses Design hat zwei große Vorteile. Zum einen herscht eine lose Kopplung zwischen
allen Programmteilen, welche das Model verändern wollen und dem Model selbst, was zur Modularität des ganzen
Programms beiträgt. Zum anderen kann man die Commands speichern und zu einem
späteren Zeitpunkt auf einen Snapshot des Modells wieder ausführen um das originale
Model wieder herzustellen. Mehr dazu im
\hyperref[subsubsec:replaylogging]{replaylogging}-Package. Weiter bietet dieses
Design den großen Vorteil das es hohes Erweiterbarkeitspotential hat. Zum Beispiel
könnte man relativ einfach eine undo- und redo-Funktion in einen Command einbauen um
zwischen verschiedene Modelzuständen hin und zurück zu springen. So eine
Funktionalität ist zwar nicht eingeplannt, aber sie währe nicht schwer zu implementieren
an Hand der Command Struktur.
\newline
\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/commands.png}
  \caption{command-Package}
\end{figure}

Es gibt 2 Arten von Commands, TruffleCommands für die Bearbeitung empfangener
Paketdaten, und UserCommands für die Verwaltung der Benutzeroberflächenbefehle.

      \subsubsection{trufflecommand}
      \label{subsubsec:trufflecommand}
      ***TruffleCommands package image goes here***
      \newline
      \newline
      Jegliche empfangenen Truffles vom \gls{praeprozessor} werden zuerst in Java-Objekt-Truffles umgewandelt, wie
      im \hyperref[subsubsec:truffleprocessor]{truffleprocessor}-Package erklärt. Dort
      werden die erzeugten Java-Truffles in ein Command gesteckt und per \gls{observerpattern}
      wie im \hyperref[subsec:util]{util}-Package beschrieben an alle Interessenten, also die \gls{listener} verschickt.
      \newline
      \newline
      Es gibt nur einen Command-Typen für die empfangen Truffle-\glspl{paket}, nämlich den
      AddPacketDataCommand. Diese Entscheidung wurde getroffen um das Programm einfach
      zu halten. Commands wie AddNode oder AddEdge sind überflüßig, da diese leicht aus
      dem Inhalt des Truffles gelesen werden können.
      \newline
      \newline
      Der PluginNotRunningCommand wird genau dann vom truffleprocessor verschickt, wenn sich \gls{programname}
      nicht mit \gls{sppname} oder einem äquivalenten Plugin verbinden konnte. Wir
      haben die Funktionalität, dass \gls{programname} automatisch \gls{sppname} startet,
      aufgegeben um die beiden Programme unabhängiger zu gestallten und um dem Benutzter
      mehr Freiheit, beispielsweise bei der \gls{praeprozessor}enwahl, zu geben.

      \subsubsection{usercommand}
      \label{subsubsec:usercommand}
      ***UserCommands package image goes here***
      \newline
      \newline

      Wenn der Benutzter eine GUI-Aktion startet, die das Model beeinflusst,
      wird ein entsprechender Command an alle \gls{listener} durch das \gls{observerpattern}, wie im
      \hyperref[subsec:util]{util}-Package beschrieben, verschickt. Für jede mögliche
      GUI-Aktion, welche das Model beeinflusst, gibt es einen passenden Command.
      Diese werden in den ViewControllern aus dem \hyperref[subsec:view]{view}-Package
      an den Executor verschickt.
      //////hier fehlt wer die usercommmands erstellt und losschickt////// **Besser? (von Julian)**

      \subsubsection{queue}
      \label{subsubsec:queue}
      Die Commands, welche beispielsweise der Executor abarbeiten soll, werden in einer passenden Datenstruktur zwischengespeichert. Es
      sind ggf. mehrere tatsächliche Queues vorhanden, was nach einem Manager verlangt
      um nach dem Round-Robin-Prnzip faire Verteilung zu ermöglichen. Diese CommandQueue ist das empfangende Ende des \gls{observerpattern} an mehreren Stellen unseres Programms.
      Bei Aktualisierung durch einen \gls{notifier} geht dieser alle seine \gls{listener} durch und fügt bei jedem in genau eben diese CommandQueue das neue Command-Objekt ein.
      Die Implementierung der Queues als BlockingQueue ermöglicht in diesem Fall die Kommunikation zwischen Threads.

\subsection{service}
\label{subsec:service}

Im service-Package befinden sich alle durchlaufenden Threads von \gls{programname},
mit Ausnahme vom \hyperref[subsec:view]{view}, das ein eigenes Package zur verzögerungsfreien Darstellung ist, und dem
main-Thread. Jedes Unterpackage kapselt dabei genau eine selbständig laufende Funktionalität, meist eine pro Thread. Unten ist erklärt, was genau jedes Unterpackage macht.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/service.png}
  \caption{service-Package}
  \medskip
\end{figure}

    \subsubsection{truffleprocessor}
    \label{subsubsec:truffleprocessor}

    *** truffleprocessor image here ***
    \newline
    \newline
    Der truffleprocessor-Service läuft konstant im Hintergrund, in einem eigenen Thread,
    und empfängt die im \gls{sppname} erstellten Truffles.
    Diese packt er in ein Java-Truffle-Objekt, welches dann wiederum von dem
    \textit{TruffleReciever} in ein Command gesteckt wird. Da der \textit{TruffleReciever}
    auch ein \gls{notifier} ist, verschickt er den Command auch gleich an
    alle registrierten \gls{listener}, sodass der CommandExecutor die bekommt wo die Commands
    als nächstes auf dem Model angewandt werden.

    \subsubsection{replaylogging}
    \label{subsubsec:replaylogging}

    *** replaylogging image here ***
    \newline
    \newline

    Der replaylogging-Service besteht aus 2 Prozessen die jeweils ihre eigenen Threads haben//same//.
    Der erste ist der \textit{DataLogSaveService} und kümmert sich um das speichern das aktuellen
    Graphen. Der zweite ist der \textit{DataLogLoadService} und kümmert sich um das
    wiederherstellen eines gespeicherten Graphen.
    \newline
    \newline
    Der \textit{DataLogSaveService} läuft konstant im Hintergrund und empfängt alle
    vom \textit{TruffleReciever} verschickten Commands. Diese werden alle X
    Sekunden (vom Benutzter festlegbar) komprimiert und in eine Liste gepackt.
    Komprimiert heißt, dass viele Commands, die das selbe tun, in ein Command
    gepackt werden. Zusätzlich zu den Commands wird auch noch ein Snapshot
    von dem aktuellen Graphen gemacht, der dann zusammen mit der erstellten
    Command-Liste in ein ReplayLog-Objekt getan wird. Dieses
    ReplayLog-Objekt wird dann von Java serialisiert und gespeichert.
    \newline
    \newline
    Diese Logs können zu einem späteren Zeitpunkt wieder geladen werden um den
    Graphen wiederherzustellen. Dazu ist der \textit{DataLogLoadService} da. Wenn
    der User die Replayfunktion aktiviert, fängt der DataLogLoadService an die
    ReplayLogs zu laden. Dann wird in der view der Snapshotgraph angezeigt
    und die gespeicherten Commands aus dem ReplayLog werden auf
    diesem Snapshot angewandt. Der DataLogLoadService kontrolliert somit die
    Wiedergabe des alten Graphen und kann sogar hin und her zwischen Snapshots
    springen (momentan nicht zwischen einzelnen Commands, da dieses keine undo-
    und redo-Funktion besitzten).
    \newline
    \newline
    Der DataLogLoadService läuft in seinem eigenen Thread, weil er sich darum
    kümmert das immer genügend Daten im Speicher liegen. In anderen Worten, er
    buffert die Replaylogs vor damit sich der Graph bei dem Benutzter flüssig
    abspielt.

    \subsubsection{executor}
    \label{subsubsec:executor}

    *** executor image here ***
    \newline
    \newline

    Der executor-Service läuft auch wieder konstant im Hintegrund in seinem
    eigenen Thread. Er ist ein \gls{listener} der sowohl bei dem TruffleReciever aus dem
    \hyperref[subsubsec:truffleprocessor]{truffleprocessor}-Package als
    auch bei den view-Controllern aus dem \hyperref[subsec:view]{view}-Package
    registriert ist. D.h. er bekommt, wie das \hyperref[subsubsec:replaylogging]{replaylogging},
    alle \hyperref[subsubsec:trufflecommand]{TruffleCommands} und führt diese
    dann auf dem aktuellen Model aus.
    \newline
    \newline
    In \gls{programname} gibt es zwei Instanzen vom Executor. Die erste bearbeitet
    den aktuellen Graphen, und die zweite bearbeitet die Snapshot-Instanz, falls
    eine existiert. So kann der aktuelle Graph up-to-date bleiben, während
    gleichzeitig der Benutzter einen alten Graphen aus
    ReplayLogs rekonstruiert anschaut.


\subsection{presenter}
\label{subsec:presenter}

Der presenter ist für den Aufbau von \gls{programname}, also das
Initialisieren, Instanziieren und Referenzieren aller Programmelemente zuständig.
Er ist sozusagen der \"glue code\" von \gls{programname}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/presenter.png}
  \caption{presenter-Package}
\end{figure}

Er wird im main-Thread von der main-Klasse erzeugt und ruft alle Konstruktoren auf.
In anderen Worten baut er \gls{programname} auf.

\subsection{util}
\label{subsec:util}

Unsere Variante des \gls{observerpattern}s.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/util.png}
  \caption{util-Package}
\end{figure}

Da wir sowohl Interfaces als auch Klassen bzw. abstrakte Klassen als
\gls{notifier} haben, kommen wir nicht um eine Modifizierung des klassischen
\gls{observerpattern} herum. Nun haben wir die Möglichkeit sowohl ein
\gls{notifier}-Interface zu erweitern als auch eine abstrakte
\gls{notifier}-Klasse zu beerben. Der \gls{listener} funktioniert genau wie ein
Observer.


\subsection{model}
\label{subsec:model}

Die Hauptdatenstruktur von \gls{programname}: das model-Package.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/model.png}
  \caption{model-Package}
\end{figure}

    \subsubsection{graph}
    \label{subsubsec:graph}
    Dieses Unterpackage macht das eigentliche Modell aus. Der gesamte Graph sowie
    all seine möglichen Layouts, entsprechende Interfaces und ein Proxy aus dem
    \gls{proxypattern} für die Entkopplung sind hier enthalten.
    \subsubsection{filter}
    \label{subsubsec:filter}

    \subsubsection{configdata}
    \label{subsubsec:configdata}

    \subsubsection{graphlog}
    \label{subsubsec:graphlog}


\subsection{view}
\label{subsec:view}

\subsection{interactors}
\label{subsec:interactors}
