\chapter{Aufbau \programname}

\section{Architekturbeschreibung}
Im Groben gehalten funktioniert der Daten- und Befehlsfluss im Trufflehog-Entwurf
wie im klassischen MVC, der Presenter aktiviert Services, welche das Model basierend
auf dem empfangenen Netzwerkverkehr verändert und das View aktualisiert sich am Model.
Da viele Threads im Programm parallel durchlaufen aber dennoch kommunizieren müssen,
verlassen wir uns an einigen Stellen auf das \gls{observerpattern} mit einer
Multi-Thread kompatiblen Datenstruktur.\newline
\newline

\section{Paketbeschreibung}

\subsection{command}
Das command-Package beinhaltet Commands. Ein command ist eine art Befehl der auf
dem Model ausgeführt wird. D.h. alle objekt die das Model irgendwie verändern
werden als command gekapselt, sodass deren veränderung als command auf dem Model
ausgeführt wird. Zum Beispiel werden alle empfangene netzwerk\glspl{paket} und
Benutzerbefehle als command gekapselt, da diese direkt das Model beeinflussen.
\newline
\newline
Dieses Design hat zwei große Vorteile. Zum einen herscht eine lose Kopplung zwischen
dem der das Model verändern will und dem Model selber, was zur modularität des ganzen
programmes hinzufügt. Zum anderen ann man die Commands speichern und zu einem
späteren Zeitpunkt auf ein Snapshot des Modelles ausführen um das originalle
model wieder herzustellen. Mehr dazu im replaylogging-Package.
\newline
\newline
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/commands.png}
  \caption{command-Package}
\end{figure}

Es gibt 2 Arten von Commands, UserCommands für die Verwaltung der
Benutzeroberflächenbefehle, und TruffleCommands für die bearbeitung empfangenen
Paketdaten. D.h. wenn der Benutzter einen Knopf drückt der das Model beeinflusst,
wird ein command an alle Listener durch das observer pattern im \hyperref[subsec:util]{util-Package})
losgeschickt.
\newline
\newline

im
Model-Graph, also die Hauptarbeit am Model. Die Commands machen außerdem den
Hauptteil der Log-Datein und damit der Video-Funktion aus. Mehr dazu im
service-Unterpackage datalogging.

    \subsubsection{Command Queue}
    Die besagte Datenstruktur, welche beispielsweise der executor besitzt. Es
    sind ggf. mehrere tatsächliche Queues vorhanden, was einen Manager verlangt
    um nach dem Round-Robin-Prinzip faire Verteilung zu ermöglichen.


\subsection{service}


In unserem Entwurf haben wir uns außerdem dazu entschieden einzelne
durchlaufende Arbeitsschritte in das \textbf{service-Package} auszulagern.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/service.png}
  \caption{service-Package}
  \medskip
\end{figure}

    \subsubsection{truffleprocessor}
    Der truffleprocessor ist die Empfangsstelle für die von uns in der
    \gls{ipc} benutzen Truffles. Außerdem erzeugt er die später verwendeten
    Commands und benachrichtigt als \gls{notifier}.

    \subsubsection{datalogging}
    Das datalogging kümmert sich um die gesamte gewünschte
    Speicherung/Loggen und, falls implementiert, die Verfügbarkeit der
    Video-Daten. Es speichert sowohl regelmäßige Snapshots des gesamten
    Graphen, als auch einzelne Commands für eine Schrittweise Rückverfolgung
    des Ablaufes.

    \subsubsection{executor}
    Der executor ist das Unterpackage, in welchem die Anwendung bzw.
    Ausführung der Commands stattfindet. Er ist ein \gls{listener} für Commands
    von sowohl dem view-Package als auch dem truffleprocessor.


\subsection{presenter}


Der presenter ist für den Aufbau von \gls{programname}, also das
Initialisieren, Instanziieren und Referenzieren aller Programmelemente zuständig.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/presenter.png}
  \caption{presenter-Package}
\end{figure}

Er ist der erste Thread und erzeugt alle weiteren, zum Beispiel einen für jeden
Service. Außerdem liest er aus einer Settings-Datei und stellt das Programm ein.
Das heisst er initialisiert bestimmte Attribute entsprechend. Danach erschöpft
sich die Nützlichkeit des presenter bis zu einem neuen Programmstart.


\subsection{util}
\label{subsec:util}


Unsere Variante des \gls{observerpattern}s.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/util.png}
  \caption{util-Package}
\end{figure}

Da wir sowohl Interfaces als auch Klassen bzw. abstrakte Klassen als
\gls{notifier} haben, kommen wir nicht um eine Modifizierung des klassischen
\gls{observerpattern} herum. Nun haben wir die Möglichkeit sowohl ein
\gls{notifier}-Interface zu erweitern als auch eine abstrakte
\gls{notifier}-Klasse zu beerben. Der \gls{listener} funktioniert genau wie ein
Observer.


\subsection{model}


Die Hauptdatenstruktur von \gls{programname}: das model-Package.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/model.png}
  \caption{model-Package}
\end{figure}

    \subsubsection{graph}
    Dieses Unterpackage macht das eigentliche Modell aus. Der gesamte Graph sowie all seine möglichen Layouts, entsprechende Interfaces und ein Proxy aus dem \gls{proxypattern} für die Entkopplung sind hier enthalten.
    \subsubsection{filter}

    \subsubsection{settingsdata}

    \subsubsection{graphlog}


\subsection{view}

\subsection{interactors}
