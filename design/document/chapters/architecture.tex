\chapter{Architektur und Musterbeschreibung}
Im Groben gehalten funktioniert der Daten- und Befehlsfluss im Trufflehog-Entwurf wie im klassischen MVC, der Presenter aktiviert Services, welche das Model basierend auf dem empfangenen Netzwerkverkehr verändert und das View aktualisiert sich am Model. Da viele Threads im Programm parallel durchlaufen aber dennoch kommunizieren müssen, verlassen wir uns an einigen Stellen auf das \gls{observerpattern} mit einer Multi-Thread kompatiblen Datenstruktur.\newline
\newline


\section{\textbf{commands-Package:}}


Die Kernfunktionalität innerhalb des Programms stellt das \textbf{commands-Package}. Darin befinden sich sowohl die Hierarchie, vorhandene Datenstruktur als auch jede mögliche Command-Klasse und deren Interface. Vom Prinzip her vergleichbar mit Runnables.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/commands.png}
  \caption{\textbf{commands-Package}}
\end{figure}

Es gibt 2 Hauptarten von Commands, UserCommands für die Verwaltung der Benutzeroberflächenbefehle, und TruffleCommands für die Methodenaufrufe im Model-Graph, also die Hauptarbeit am Model. Die Commands machen außerdem den Hauptteil der Log-Datein und damit der Video-Funktion aus. Mehr dazu im service-Unterpackage datalogging.

    \subsection*{\textbf{commandQueue}}
    Die besagte Datenstruktur, welche beispielsweise der executor besitzt. Es sind ggf. mehrere tatsächliche Queues vorhanden, was einen Manager verlangt um nach dem Round-Robin-Prinzip faire Verteilung zu ermöglichen.


\section{\textbf{service-Package:}}


In unserem Entwurf haben wir uns außerdem dazu entschieden einzelne durchlaufende Arbeitsschritte in das \textbf{Service-Package} auszulagern.\newline

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/service.png}
  \caption{\textbf{service-Package}}
  \medskip
\end{figure}

    \subsection*{\textbf{truffleprocessor}}
    Der \textbf{truffleprocessor} ist die Empfangsstelle für die von uns in der \gls{ipc} benutzen Truffles. Außerdem erzeugt er die später verwendeten Commands und benachrichtigt als \gls{notifier}.
    
    \subsection*{\textbf{datalogging}}
    Das \textbf{datalogging} kümmert sich um die gesamte gewünschte Speicherung/Loggen und, falls implementiert, die Verfügbarkeit der Video-Daten. Es speichert sowohl regelmäßige Snapshots des gesamten Graphen, als auch einzelne Commands für eine Schrittweise Rückverfolgung des Ablaufes.
    
    \subsection*{\textbf{executor}}
    Der \textbf{executor} ist das Unterpackage, in welchem die Anwendung bzw. Ausführung der Commands stattfindet. Er ist ein \gls{listener} für Commands von sowohl dem view-Package als auch dem truffleprocessor.


\section{\textbf{presenter-Package:}}


Der \textbf{presenter} ist für den Aufbau von \gls{programname}, also das Initialisieren, Instanziieren und Referenzieren aller Programmelemente zuständig.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/presenter.png}
  \caption{\textbf{presenter}}
\end{figure}

Er ist der erste Thread und erzeugt alle weiteren, zum Beispiel einen für jeden Service. Außerdem liest er aus einer Settings-Datei und stellt das Programm ein.
Das heisst er initialisiert bestimmte Attribute entsprechend. Danach erschöpft sich die Nützlichkeit des \textbf{presenter} bis zu einem neuen Programmstart.


\section{\textbf{util-Package:}}


Unsere Variante des \gls{observerpattern}s.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/util.png}
  \caption{\textbf{util-Package}}
\end{figure}

Da wir sowohl Interfaces als auch Klassen bzw. abstrakte Klassen als \gls{notifier} haben, kommen wir nicht um eine Modifizierung des klassischen \gls{observerpattern} herum. Nun haben wir die Möglichkeit sowohl ein \gls{notifier}-Interface zu erweitern als auch eine abstrakte \gls{notifier}-Klasse zu beerben. Der \gls{listener} funktioniert genau wie ein Observer.


\section{\textbf{model-Package:}}


Die Hauptdatenstruktur von \gls{programname}: das \textbf{model-Package}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{../diagramimages/model.png}
  \caption{\textbf{model-Package}}
\end{figure}

    \subsection*{\textbf{graph}}
    
    \subsection*{\textbf{filter}}
    
    \subsection*{\textbf{settingsdata}}
    
    \subsection*{\textbf{graphlog}}


\section{\textbf{view-Package:}}


\section{\textbf{interactors-Package:}}
